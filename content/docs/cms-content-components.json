{
	"title": "Content Components",
	"group": "CMS",
	"order": 8.07,
	"body": "A common setup for Plenti sites is to use a content-driven component approach. This enables changes that are made in the JSON content source to inform the component display on the frontend of the website. Ultimately this allows content editors to make changes in the CMS to add/remove or reorder components on the page without having to edit any HTML code. It also allows the designer/developer who created the site to enforce a style guide that is more rigid than unstructured WYSIWYG while still allowing more flexibility than a predefined template.<br><div><div><h2>Creating new component content</h2></div><div>Component defaults are defined in a similar manner to content type defaults, however they <i>must</i>&nbsp;go in a special named folded called <code>_components</code> inside your top level content folder&nbsp;(e.g. <code>content/_components/grid/_defaults.json</code>). Components do not get their own pages/endpoints, they only exist within the context of being placed on a particular page. In order to do this, you need a content type (or another component) with a <code>_schema.json</code> file that specifies a component widget for one of its fields:</div><div><br></div><codeblock>{<br>&nbsp; \"myfield\": {<br>&nbsp; &nbsp; \"type\": \"component\",<br>&nbsp; &nbsp; \"options\": [<br>&nbsp; &nbsp; &nbsp; \"hero\",<br>&nbsp; &nbsp; &nbsp; \"grid\",<br>&nbsp; &nbsp; &nbsp; \"slider\"<br>&nbsp; &nbsp; ]<br>&nbsp; }<br>}</codeblock></div><h2>Nested Components</h2><div>Components are global in nature so they all sit at the same level in the <code>_components</code> folder, but can reference each other. There is no limit to how many levels deep you can nest, but the editing experience could get clunky and performance might degrade if you push this too far.&nbsp;</div>"
}