/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	append,
	attr,
	children,
	claim_element,
	claim_space,
	destroy_each,
	detach,
	element,
	init,
	insert,
	is_function,
	listen,
	noop,
	safe_not_equal,
	space
} from '../../web_modules/svelte/internal/index.mjs';

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (27:36) 
function create_if_block_1(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			this.h();
		},
		l(nodes) {
			img = claim_element(nodes, "IMG", { src: true, class: true });
			this.h();
		},
		h() {
			if (img.src !== (img_src_value = /*file*/ ctx[5])) attr(img, "src", img_src_value);
			attr(img, "class", "svelte-1b5atfm");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*files*/ 2 && img.src !== (img_src_value = /*file*/ ctx[5])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (25:12) {#if isPDF(file)}
function create_if_block(ctx) {
	let embed;
	let embed_src_value;

	return {
		c() {
			embed = element("embed");
			this.h();
		},
		l(nodes) {
			embed = claim_element(nodes, "EMBED", { src: true, type: true, class: true });
			this.h();
		},
		h() {
			if (embed.src !== (embed_src_value = /*file*/ ctx[5])) attr(embed, "src", embed_src_value);
			attr(embed, "type", "application/pdf");
			attr(embed, "class", "svelte-1b5atfm");
		},
		m(target, anchor) {
			insert(target, embed, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*files*/ 2 && embed.src !== (embed_src_value = /*file*/ ctx[5])) {
				attr(embed, "src", embed_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(embed);
		}
	};
}

// (23:4) {#each files as file}
function create_each_block(ctx) {
	let div;
	let show_if;
	let show_if_1;
	let t;
	let div_class_value;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (show_if == null || dirty & /*files*/ 2) show_if = !!/*isPDF*/ ctx[3](/*file*/ ctx[5]);
		if (show_if) return create_if_block;
		if (show_if_1 == null || dirty & /*files*/ 2) show_if_1 = !!/*isImage*/ ctx[2](/*file*/ ctx[5]);
		if (show_if_1) return create_if_block_1;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", div_class_value = "media" + (/*selectedMedia*/ ctx[0].includes(/*file*/ ctx[5])
			? " selected"
			: "") + " svelte-1b5atfm");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);

			if (!mounted) {
				dispose = listen(div, "click", function () {
					if (is_function(/*selectMedia*/ ctx[4](/*file*/ ctx[5]))) /*selectMedia*/ ctx[4](/*file*/ ctx[5]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, t);
				}
			}

			if (dirty & /*selectedMedia, files*/ 3 && div_class_value !== (div_class_value = "media" + (/*selectedMedia*/ ctx[0].includes(/*file*/ ctx[5])
			? " selected"
			: "") + " svelte-1b5atfm")) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);

			if (if_block) {
				if_block.d();
			}

			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let div;
	let each_value = /*files*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "media-browser svelte-1b5atfm");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*selectedMedia, files, selectMedia, isPDF, isImage*/ 31) {
				each_value = /*files*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			destroy_each(each_blocks, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { files } = $$props;
	let { selectedMedia = [] } = $$props;

	const isImage = file => {
		let extensions = ["jpg", "jpeg", "png", "webp", "gif", "svg", "avif", "apng"];
		let reImage = new RegExp("^data:image/(?:" + extensions.join("|") + ")(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}");
		return extensions.includes(file.substr(file.lastIndexOf(".") + 1)) || reImage.test(file);
	};

	const isPDF = file => {
		let extensions = ["pdf", "msword"];
		let rePDF = new RegExp("^data:application/(?:" + extensions.join("|") + ")(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}");
		return extensions.includes(file.substr(file.lastIndexOf(".") + 1)) || rePDF.test(file);
	};

	const selectMedia = file => {
		if (selectedMedia.includes(file)) {
			$$invalidate(0, selectedMedia = selectedMedia.filter(m => m !== file));
		} else {
			$$invalidate(0, selectedMedia = [...selectedMedia, file]);
		}
	};

	$$self.$$set = $$props => {
		if ("files" in $$props) $$invalidate(1, files = $$props.files);
		if ("selectedMedia" in $$props) $$invalidate(0, selectedMedia = $$props.selectedMedia);
	};

	return [selectedMedia, files, isImage, isPDF, selectMedia];
}

class Component extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { files: 1, selectedMedia: 0 });
	}
}

export default Component;