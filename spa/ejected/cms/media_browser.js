/* generated by Svelte v3.38.3 */
import {
	SvelteComponent,
	append,
	attr,
	children,
	claim_component,
	claim_element,
	claim_space,
	claim_text,
	create_component,
	destroy_component,
	destroy_each,
	detach,
	element,
	handle_promise,
	init,
	insert,
	is_function,
	listen,
	mount_component,
	noop,
	safe_not_equal,
	set_data,
	space,
	svg_element,
	text,
	transition_in,
	transition_out,
	update_await_block_branch
} from '../../web_modules/svelte/internal/index.mjs';

import { getAssets } from './get_assets.js';
import { env } from '../env.js';
import MediaGrid from './media_grid.js';

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

// (1:0) <script>     import { getAssets }
function create_catch_block(ctx) {
	return {
		c: noop,
		l: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (58:4) {:then _}
function create_then_block(ctx) {
	let div1;
	let div0;
	let t0;
	let t1;
	let mediagrid;
	let current;
	let each_value = /*filters*/ ctx[2];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let if_block = /*enabledFilters*/ ctx[3].length > 0 && create_if_block(ctx);

	mediagrid = new MediaGrid({
			props: {
				files: /*applyFilters*/ ctx[5](/*allFiles*/ ctx[1])
			}
		});

	return {
		c() {
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			create_component(mediagrid.$$.fragment);
			this.h();
		},
		l(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach);
			t0 = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			div1_nodes.forEach(detach);
			t1 = claim_space(nodes);
			claim_component(mediagrid.$$.fragment, nodes);
			this.h();
		},
		h() {
			attr(div0, "class", "filters svelte-1n4s42m");
			attr(div1, "class", "filters-wrapper svelte-1n4s42m");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			append(div1, t0);
			if (if_block) if_block.m(div1, null);
			insert(target, t1, anchor);
			mount_component(mediagrid, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*enabledFilters, filters, toggleFilter*/ 28) {
				each_value = /*filters*/ ctx[2];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*enabledFilters*/ ctx[3].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			const mediagrid_changes = {};
			if (dirty & /*allFiles*/ 2) mediagrid_changes.files = /*applyFilters*/ ctx[5](/*allFiles*/ ctx[1]);
			mediagrid.$set(mediagrid_changes);
		},
		i(local) {
			if (current) return;
			transition_in(mediagrid.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(mediagrid.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
			if (detaching) detach(t1);
			destroy_component(mediagrid, detaching);
		}
	};
}

// (61:12) {#each filters as filter}
function create_each_block(ctx) {
	let div;
	let t_value = /*filter*/ ctx[10] + "";
	let t;
	let div_class_value;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", div_class_value = "filter" + (/*enabledFilters*/ ctx[3].includes(/*filter*/ ctx[10])
			? " active"
			: "") + " svelte-1n4s42m");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);

			if (!mounted) {
				dispose = listen(div, "click", function () {
					if (is_function(/*toggleFilter*/ ctx[4](/*filter*/ ctx[10]))) /*toggleFilter*/ ctx[4](/*filter*/ ctx[10]).apply(this, arguments);
				});

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*filters*/ 4 && t_value !== (t_value = /*filter*/ ctx[10] + "")) set_data(t, t_value);

			if (dirty & /*enabledFilters, filters*/ 12 && div_class_value !== (div_class_value = "filter" + (/*enabledFilters*/ ctx[3].includes(/*filter*/ ctx[10])
			? " active"
			: "") + " svelte-1n4s42m")) {
				attr(div, "class", div_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (65:12) {#if enabledFilters.length > 0}
function create_if_block(ctx) {
	let div;
	let svg;
	let path;
	let line0;
	let line1;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			svg = svg_element("svg");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			svg = claim_element(
				div_nodes,
				"svg",
				{
					xmlns: true,
					class: true,
					width: true,
					height: true,
					viewBox: true,
					"stroke-width": true,
					stroke: true,
					fill: true,
					"stroke-linecap": true,
					"stroke-linejoin": true
				},
				1
			);

			var svg_nodes = children(svg);
			path = claim_element(svg_nodes, "path", { stroke: true, d: true, fill: true }, 1);
			children(path).forEach(detach);
			line0 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line0).forEach(detach);
			line1 = claim_element(svg_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line1).forEach(detach);
			svg_nodes.forEach(detach);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(path, "stroke", "none");
			attr(path, "d", "M0 0h24v24H0z");
			attr(path, "fill", "none");
			attr(line0, "x1", "18");
			attr(line0, "y1", "6");
			attr(line0, "x2", "6");
			attr(line0, "y2", "18");
			attr(line1, "x1", "6");
			attr(line1, "y1", "6");
			attr(line1, "x2", "18");
			attr(line1, "y2", "18");
			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr(svg, "class", "icon icon-tabler icon-tabler-x");
			attr(svg, "width", "20");
			attr(svg, "height", "20");
			attr(svg, "viewBox", "5 5 14 14");
			attr(svg, "stroke-width", "1.5");
			attr(svg, "stroke", "#2c3e50");
			attr(svg, "fill", "none");
			attr(svg, "stroke-linecap", "round");
			attr(svg, "stroke-linejoin", "round");
			attr(div, "class", "close svelte-1n4s42m");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, svg);
			append(svg, path);
			append(svg, line0);
			append(svg, line1);

			if (!mounted) {
				dispose = listen(div, "click", /*click_handler*/ ctx[6]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(div);
			mounted = false;
			dispose();
		}
	};
}

// (56:18)          Loading...         {:then _}
function create_pending_block(ctx) {
	let t;

	return {
		c() {
			t = text("Loading...");
		},
		l(nodes) {
			t = claim_text(nodes, "Loading...");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let promise;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 9,
		blocks: [,,,]
	};

	handle_promise(promise = /*links*/ ctx[0], info);

	return {
		c() {
			div = element("div");
			info.block.c();
			this.h();
		},
		l(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			info.block.l(div_nodes);
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(div, "class", "media-wrapper svelte-1n4s42m");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			info.block.m(div, info.anchor = null);
			info.mount = () => div;
			info.anchor = null;
			current = true;
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;
			info.ctx = ctx;

			if (dirty & /*links*/ 1 && promise !== (promise = /*links*/ ctx[0]) && handle_promise(promise, info)) {
				
			} else {
				update_await_block_branch(info, ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			info.block.d();
			info.token = null;
			info = null;
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let assetsDir = env.baseurl ? "assets/" : "/assets/";

	let links = new Promise(() => {
			
		});

	let allFiles = [];
	let filters = [];

	const readDir = async dir => {
		$$invalidate(0, links = await getAssets(dir));

		links.forEach(link => {
			let linkPath = dir + link.innerHTML;

			if (linkPath.includes(".")) {
				$$invalidate(1, allFiles = [...allFiles, linkPath]);
			} else {
				let filter = link.innerHTML;
				filter = filter.endsWith("/") ? filter.slice(0, -1) : filter;
				$$invalidate(2, filters = [...filters, filter]);
				readDir(linkPath);
			}
		});
	};

	readDir(assetsDir);
	let enabledFilters = [];

	const toggleFilter = filter => {
		if (!filter) {
			$$invalidate(3, enabledFilters = []);
		} else {
			if (enabledFilters.includes(filter)) {
				$$invalidate(3, enabledFilters = enabledFilters.filter(f => f !== filter));
			} else {
				$$invalidate(3, enabledFilters = [...enabledFilters, filter]);
			}
		}

		$$invalidate(1, allFiles); // Force #each loop in template to rerender
	};

	const applyFilters = allFiles => {
		if (enabledFilters.length > 0) {
			let fileList = [];

			enabledFilters.forEach(filter => {
				fileList = [
					...fileList,
					...allFiles.filter(linkPath => {
						let parts = linkPath.split("/");
						return parts.includes(filter) && !fileList.includes(linkPath);
					})
				];
			});

			return fileList;
		} else {
			return allFiles;
		}
	};

	const click_handler = () => toggleFilter(false);

	return [
		links,
		allFiles,
		filters,
		enabledFilters,
		toggleFilter,
		applyFilters,
		click_handler
	];
}

class Component extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Component;